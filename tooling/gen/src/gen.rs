typo_fix_pairs! {
    "don;t" -> "don't",
    "won;t" -> "won't",
    "can;t" -> "can't",
    "repetion" -> "repetition",
    "preferrable" -> "preferable",
}

// Wrapped in a module so we can put the invocation above the macro definition,
// in the file.
mod typo_fix_pairs {
    #[macro_export]
    macro_rules! typo_fix_pairs {
        (
            $( $typo: literal -> $fix: literal $(,)? )+
        ) => {
            const LENGTH: usize = {
                let mut length = 0;

                $(
                    // Use $typo just so we can use the repetition to do the counting.
                    let _ = $typo;
                    length += 1;
                )*

                length
            };

            const UNNORMALIZED_TYPO_FIX_PAIRS: [(&str, &str); LENGTH] = [
                $(
                    ($typo, $fix),
                )*
            ];
        }
    }

    pub use typo_fix_pairs;
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    use std::fs::OpenOptions;
    use std::io::Write;

    {
        let cwd = std::env::current_dir()?;
        if !cwd.ends_with("tooling/gen") {
            return Err(format!(
                "This program expects to be run in tooling/gen, but it was run in {}",
                cwd.display()
            ).into());
        }
    }

    const PATH: &str = "../../src/known_typos.rs";

    let mut file = OpenOptions::new()
        .write(true)
        .truncate(true)
        .create(false)
        .open(PATH)?;

    #[derive(Clone, Copy, Debug, PartialEq)]
    enum Transform {
        NoChange,
        UppercaseFirst,
    }

    let sorted_typo_fixes = {
        let mut typo_fixes = Vec::with_capacity(
            UNNORMALIZED_TYPO_FIX_PAIRS.len() * 2
        );

        for (typo, fix) in UNNORMALIZED_TYPO_FIX_PAIRS {
            // Uppercase comes first in ASCII, so put it in the list first.
            typo_fixes.push(
                // If this uppercasing turns out to be undesirable in some cases
                // later, we can add a set of flags to each pair, indicating what
                // options should be pushed.
                (typo, fix, Transform::UppercaseFirst)
            );

            typo_fixes.push((typo, fix, Transform::NoChange));
        }

        // We rely on this sort being stable to put the first one only if we ever do
        // have any duplicates! Having an addition at the end be a no-op seems
        // preferable to potentially different behavior across gen runs with
        // different stdlib versions or whatever.
        typo_fixes.sort_by_key(|tuple| tuple.0);
        typo_fixes.dedup_by_key(|tuple| (tuple.0, tuple.2));
        typo_fixes
    };

    let length = sorted_typo_fixes.len();

    // TODO? Precalculate the buffer size so we only emit one write syscall.
    write!(file, r#"
///! This file was generated by tooling/gen. Edit the source data and run
///! that generator instead of hand-editing this file.

const LENGTH: usize = {length};

pub const TYPOS: [&str; LENGTH] = [
"#)?;

    for (typo, _, transform) in sorted_typo_fixes.iter() {
        match transform {
            Transform::NoChange => {
                writeln!(file, "    \"{typo}\",")?;
            }
            Transform::UppercaseFirst => {
                writeln!(file, "    \"{}\",", UppercaseFirst(typo))?;
            }
        }
    }

    write!(file, r#"];

pub const FIXES: [&str; LENGTH] = [
"#)?;

    for (_, fix, transform) in sorted_typo_fixes.iter() {
        match transform {
            Transform::NoChange => {
                writeln!(file, "    \"{fix}\",")?;
            }
            Transform::UppercaseFirst => {
                writeln!(file, "    \"{}\",", UppercaseFirst(fix))?;
            }
        }
    }

    write!(file, r#"];
"#)?;

    println!("Overwrote {PATH} successfully");

    Ok(())
}

struct UppercaseFirst(&'static str);

impl core::fmt::Display for UppercaseFirst {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut first = true;
        for ch in self.0.chars() {
            if first {
                for c in ch.to_uppercase() {
                    write!(f, "{c}")?;
                }
                first = false;
                continue
            }
            write!(f, "{ch}")?;
        }
        Ok(())
    }
}
